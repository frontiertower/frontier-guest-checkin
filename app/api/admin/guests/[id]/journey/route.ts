import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    // Get guest details
    const guest = await prisma.guest.findUnique({
      where: { id },
      include: {
        visits: {
          include: {
            host: {
              select: { name: true, email: true }
            },
            invitation: {
              include: {
                host: {
                  select: { name: true, email: true }
                }
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        },
        invitations: {
          include: {
            host: {
              select: { name: true, email: true }
            }
          },
          orderBy: { createdAt: 'desc' }
        },
        acceptances: {
          orderBy: { acceptedAt: 'desc' }
        },
        discounts: {
          orderBy: { triggeredAt: 'desc' }
        }
      }
    });

    if (!guest) {
      return NextResponse.json(
        { error: 'Guest not found' },
        { status: 404 }
      );
    }

    // Build timeline events
    const timeline = [];

    // Guest registration
    timeline.push({
      type: 'registration',
      timestamp: guest.createdAt,
      title: 'Guest Registered',
      description: `Account created for ${guest.name}`,
      icon: 'user-plus',
      severity: 'info',
      data: {
        email: guest.email,
        country: guest.country,
        contactMethod: guest.contactMethod
      }
    });

    // Terms acceptance events
    guest.acceptances.forEach(acceptance => {
      timeline.push({
        type: 'terms_acceptance',
        timestamp: acceptance.acceptedAt,
        title: 'Terms Accepted',
        description: `Accepted terms v${acceptance.termsVersion} and visitor agreement v${acceptance.visitorAgreementVersion}`,
        icon: 'file-check',
        severity: 'success',
        data: {
          termsVersion: acceptance.termsVersion,
          visitorAgreementVersion: acceptance.visitorAgreementVersion
        }
      });
    });

    // Process invitations and their related events
    guest.invitations.forEach(invitation => {
      // Invitation created
      timeline.push({
        type: 'invitation_created',
        timestamp: invitation.createdAt,
        title: 'Invitation Created',
        description: `Invited by ${invitation.host.name} for ${new Date(invitation.inviteDate).toLocaleDateString()}`,
        icon: 'mail',
        severity: 'info',
        data: {
          hostName: invitation.host.name,
          hostEmail: invitation.host.email,
          inviteDate: invitation.inviteDate,
          status: invitation.status,
          invitationId: invitation.id
        }
      });

      // QR code activation
      if (invitation.qrIssuedAt) {
        timeline.push({
          type: 'qr_activation',
          timestamp: invitation.qrIssuedAt,
          title: 'QR Code Activated',
          description: `QR code generated by ${invitation.host.name}${invitation.qrExpiresAt ? ` (expires ${new Date(invitation.qrExpiresAt).toLocaleString()})` : ''}`,
          icon: 'qr-code',
          severity: 'success',
          data: {
            hostName: invitation.host.name,
            qrExpiresAt: invitation.qrExpiresAt,
            invitationId: invitation.id
          }
        });
      }
    });

    // Visit events
    guest.visits.forEach(visit => {
      if (visit.checkedInAt) {
        // Check if there's an invitation host different from visit host
        const invitationHost = visit.invitation?.host;
        const isHostMismatch = invitationHost && invitationHost.email !== visit.host.email;
        
        let description = `Visited ${visit.host.name}`;
        if (isHostMismatch) {
          description += ` (Originally invited by ${invitationHost.name})`;
        }
        if (visit.overrideReason) {
          description += ` • Override: ${visit.overrideReason}`;
        }
        if (visit.expiresAt) {
          description += ` • Expires ${new Date(visit.expiresAt).toLocaleString()}`;
        }
        
        timeline.push({
          type: 'checkin',
          timestamp: visit.checkedInAt,
          title: isHostMismatch ? 'Checked In (Host Transfer)' : 'Checked In',
          description,
          icon: visit.overrideReason ? 'shield-alert' : (isHostMismatch ? 'user-check' : 'user-check'),
          severity: visit.overrideReason ? 'warning' : (isHostMismatch ? 'info' : 'success'),
          data: {
            hostName: visit.host.name,
            hostEmail: visit.host.email,
            overrideReason: visit.overrideReason,
            expiresAt: visit.expiresAt,
            visitId: visit.id,
            invitationHost: invitationHost ? {
              name: invitationHost.name,
              email: invitationHost.email
            } : null,
            isHostMismatch
          }
        });
      }

      if (visit.checkedOutAt) {
        timeline.push({
          type: 'checkout',
          timestamp: visit.checkedOutAt,
          title: 'Checked Out',
          description: `Left the building`,
          icon: 'user-x',
          severity: 'info',
          data: {
            visitId: visit.id,
            duration: visit.checkedInAt ? 
              Math.round((new Date(visit.checkedOutAt).getTime() - new Date(visit.checkedInAt).getTime()) / (1000 * 60)) + ' minutes' 
              : null
          }
        });
      }
    });

    // Discount events
    guest.discounts.forEach(discount => {
      timeline.push({
        type: 'discount',
        timestamp: discount.triggeredAt,
        title: 'Discount Earned',
        description: `Third visit discount ${discount.emailSent ? 'sent to email' : 'triggered'}${discount.sentAt ? ` on ${new Date(discount.sentAt).toLocaleDateString()}` : ''}`,
        icon: 'gift',
        severity: 'success',
        data: {
          emailSent: discount.emailSent,
          sentAt: discount.sentAt
        }
      });
    });

    // Blacklist event
    if (guest.blacklistedAt) {
      timeline.push({
        type: 'blacklist',
        timestamp: guest.blacklistedAt,
        title: 'Blacklisted',
        description: 'Guest was added to blacklist',
        icon: 'ban',
        severity: 'error',
        data: {}
      });
    }

    // Sort timeline by timestamp (most recent first)
    timeline.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    // Calculate summary statistics
    const summary = {
      totalVisits: guest.visits.filter(v => v.checkedInAt).length,
      totalInvitations: guest.invitations.length,
      discountsEarned: guest.discounts.length,
      isBlacklisted: !!guest.blacklistedAt,
      lastVisit: guest.visits.find(v => v.checkedInAt)?.checkedInAt,
      firstVisit: guest.visits.filter(v => v.checkedInAt).sort((a, b) => 
        new Date(a.checkedInAt!).getTime() - new Date(b.checkedInAt!).getTime()
      )[0]?.checkedInAt,
      averageVisitsPerMonth: calculateAverageVisitsPerMonth(guest.visits),
      mostFrequentHost: getMostFrequentHost(guest.visits),
      mostFrequentInviter: getMostFrequentInviter(guest.invitations),
      hostTransferCount: getHostTransferCount(guest.visits),
      uniqueHosts: getUniqueHostCount(guest.visits, guest.invitations)
    };

    return NextResponse.json({
      guest: {
        id: guest.id,
        name: guest.name,
        email: guest.email,
        country: guest.country,
        contactMethod: guest.contactMethod,
        contactValue: guest.contactValue,
        createdAt: guest.createdAt,
        blacklistedAt: guest.blacklistedAt
      },
      timeline,
      summary
    });

  } catch (error) {
    console.error('Error fetching guest journey:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

function calculateAverageVisitsPerMonth(visits: Array<{ checkedInAt: Date | null }>): number {
  const validVisits = visits.filter(v => v.checkedInAt);
  if (validVisits.length === 0) return 0;

  const firstVisit = new Date(Math.min(...validVisits.map(v => new Date(v.checkedInAt!).getTime())));
  const lastVisit = new Date(Math.max(...validVisits.map(v => new Date(v.checkedInAt!).getTime())));
  
  const monthsDiff = (lastVisit.getTime() - firstVisit.getTime()) / (1000 * 60 * 60 * 24 * 30);
  
  return monthsDiff > 0 ? Math.round((validVisits.length / monthsDiff) * 10) / 10 : validVisits.length;
}

function getMostFrequentHost(visits: Array<{ checkedInAt: Date | null; host: { name: string; email: string } }>): { name: string; count: number } | null {
  const hostCounts: { [key: string]: { name: string; count: number } } = {};
  
  visits.forEach(visit => {
    if (visit.checkedInAt && visit.host) {
      const hostId = visit.host.email;
      if (hostCounts[hostId]) {
        hostCounts[hostId].count++;
      } else {
        hostCounts[hostId] = {
          name: visit.host.name,
          count: 1
        };
      }
    }
  });

  const hosts = Object.values(hostCounts);
  if (hosts.length === 0) return null;

  return hosts.reduce((prev, current) => (prev.count > current.count) ? prev : current);
}

function getMostFrequentInviter(invitations: Array<{ host: { name: string; email: string } }>): { name: string; count: number } | null {
  const inviterCounts: { [key: string]: { name: string; count: number } } = {};
  
  invitations.forEach(invitation => {
    if (invitation.host) {
      const inviterId = invitation.host.email;
      if (inviterCounts[inviterId]) {
        inviterCounts[inviterId].count++;
      } else {
        inviterCounts[inviterId] = {
          name: invitation.host.name,
          count: 1
        };
      }
    }
  });

  const inviters = Object.values(inviterCounts);
  if (inviters.length === 0) return null;

  return inviters.reduce((prev, current) => (prev.count > current.count) ? prev : current);
}

function getHostTransferCount(visits: Array<{ checkedInAt: Date | null; host: { email: string }; invitation?: { host: { email: string } } | null }>): number {
  return visits.filter(visit => {
    if (!visit.checkedInAt || !visit.invitation?.host) return false;
    return visit.host.email !== visit.invitation.host.email;
  }).length;
}

function getUniqueHostCount(visits: Array<{ host: { email: string } }>, invitations: Array<{ host: { email: string } }>): { visits: number; invitations: number; total: number } {
  const visitHostEmails = new Set(visits.map(v => v.host.email));
  const invitationHostEmails = new Set(invitations.map(i => i.host.email));
  const allHostEmails = new Set([...visitHostEmails, ...invitationHostEmails]);
  
  return {
    visits: visitHostEmails.size,
    invitations: invitationHostEmails.size,
    total: allHostEmails.size
  };
}